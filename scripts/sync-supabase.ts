/**
 * Supabase Database Sync Script
 *
 * Synchronizes local database schema with Supabase, generates TypeScript types,
 * and ensures migrations are up to date.
 *
 * Features:
 * - Generates TypeScript types from Supabase schema
 * - Pushes migrations to Supabase
 * - Validates connection before operations
 * - Structured logging (HIPAA-compliant)
 *
 * Usage:
 *   pnpm tsx scripts/sync-supabase.ts
 *   pnpm db:sync
 *
 * Required environment variables:
 *   SUPABASE_PROJECT_REF - Your Supabase project reference ID
 *   SUPABASE_URL - Supabase project URL (optional, for validation)
 *   SUPABASE_SERVICE_KEY - Service role key (optional, for validation)
 */

import { execSync, type ExecSyncOptions } from 'child_process';
import fs from 'fs';
import path from 'path';

// =============================================================================
// Configuration
// =============================================================================

const CONFIG = {
  // Output path for generated types
  typesOutputPath: path.resolve(process.cwd(), 'packages/types/src/supabase.generated.ts'),

  // Supabase migrations directory
  migrationsDir: path.resolve(process.cwd(), 'supabase/migrations'),

  // Command execution options
  execOptions: {
    stdio: 'pipe',
    encoding: 'utf-8',
    timeout: 120_000, // 2 minutes timeout
  } satisfies ExecSyncOptions,
};

// =============================================================================
// Types
// =============================================================================

interface SyncResult {
  success: boolean;
  typesGenerated: boolean;
  migrationsPushed: boolean;
  errors: string[];
  duration: number;
}

// =============================================================================
// Utilities
// =============================================================================

/**
 * Log with timestamp prefix
 */
function log(message: string, level: 'info' | 'warn' | 'error' = 'info'): void {
  const timestamp = new Date().toISOString();
  const prefix = {
    info: '',
    warn: '[WARN] ',
    error: '[ERROR] ',
  }[level];

  console.log(`${timestamp} ${prefix}${message}`);
}

/**
 * Execute command and return output
 */
function exec(command: string, options?: ExecSyncOptions): string {
  try {
    const result = execSync(command, {
      ...CONFIG.execOptions,
      ...options,
    });
    return typeof result === 'string' ? result : result?.toString() ?? '';
  } catch (error: unknown) {
    const execError = error as { stderr?: Buffer | string; message?: string };
    const stderr = execError.stderr?.toString() ?? execError.message ?? 'Unknown error';
    throw new Error(stderr);
  }
}

/**
 * Validate required environment variables
 */
function validateEnvironment(): { projectRef: string; errors: string[] } {
  const errors: string[] = [];

  const projectRef = process.env.SUPABASE_PROJECT_REF;
  if (!projectRef) {
    errors.push('SUPABASE_PROJECT_REF environment variable is required');
  }

  // Optional: Check if supabase CLI is installed
  try {
    exec('npx supabase --version');
  } catch {
    errors.push('Supabase CLI not found. Install with: npm install supabase --save-dev');
  }

  return { projectRef: projectRef ?? '', errors };
}

/**
 * Ensure output directory exists
 */
function ensureDirectoryExists(filePath: string): void {
  const dir = path.dirname(filePath);
  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir, { recursive: true });
  }
}

// =============================================================================
// Sync Operations
// =============================================================================

/**
 * Generate TypeScript types from Supabase schema
 */
function generateTypes(projectRef: string): { success: boolean; error?: string } {
  log('Generating TypeScript types from Supabase schema...');

  try {
    ensureDirectoryExists(CONFIG.typesOutputPath);

    const command = `npx supabase gen types typescript --project-id ${projectRef}`;
    const types = exec(command);

    if (!types || types.trim().length === 0) {
      return { success: false, error: 'Generated types are empty' };
    }

    // Add header comment
    const header = `/**
 * Supabase Generated Types
 *
 * AUTO-GENERATED FILE - DO NOT EDIT DIRECTLY
 * Generated by: pnpm db:sync
 * Generated at: ${new Date().toISOString()}
 * Project: ${projectRef}
 *
 * Regenerate with: pnpm db:sync
 */

`;

    fs.writeFileSync(CONFIG.typesOutputPath, header + types, 'utf-8');

    log(`Types written to: ${CONFIG.typesOutputPath}`);
    return { success: true };
  } catch (error: unknown) {
    const message = error instanceof Error ? error.message : String(error);
    return { success: false, error: message };
  }
}

/**
 * Push migrations to Supabase
 */
function pushMigrations(): { success: boolean; error?: string } {
  log('Pushing migrations to Supabase...');

  // Check migrations directory exists
  if (!fs.existsSync(CONFIG.migrationsDir)) {
    return { success: false, error: `Migrations directory not found: ${CONFIG.migrationsDir}` };
  }

  // Count migration files
  const migrationFiles = fs
    .readdirSync(CONFIG.migrationsDir)
    .filter((f) => f.endsWith('.sql'));

  if (migrationFiles.length === 0) {
    log('No migration files found, skipping push', 'warn');
    return { success: true };
  }

  log(`Found ${migrationFiles.length} migration file(s)`);

  try {
    const output = exec('npx supabase db push', {
      cwd: path.resolve(process.cwd(), 'supabase'),
      stdio: 'pipe',
    });

    if (output) {
      log(output.trim());
    }

    return { success: true };
  } catch (error: unknown) {
    const message = error instanceof Error ? error.message : String(error);
    return { success: false, error: message };
  }
}

// =============================================================================
// Main Function
// =============================================================================

async function main(): Promise<void> {
  const startTime = Date.now();

  console.log('================================================');
  console.log('  MedicalCor Supabase Sync');
  console.log('================================================\n');

  // Initialize result
  const result: SyncResult = {
    success: false,
    typesGenerated: false,
    migrationsPushed: false,
    errors: [],
    duration: 0,
  };

  // Validate environment
  const { projectRef, errors: envErrors } = validateEnvironment();

  if (envErrors.length > 0) {
    envErrors.forEach((e) => log(e, 'error'));
    console.log('\nUsage:');
    console.log('  SUPABASE_PROJECT_REF=your-project-ref pnpm db:sync\n');
    process.exit(1);
  }

  log(`Project: ${projectRef}`);
  log(`Types output: ${CONFIG.typesOutputPath}`);
  log(`Migrations dir: ${CONFIG.migrationsDir}\n`);

  // Generate types
  const typesResult = generateTypes(projectRef);
  result.typesGenerated = typesResult.success;

  if (!typesResult.success && typesResult.error) {
    result.errors.push(`Types generation failed: ${typesResult.error}`);
    log(typesResult.error, 'error');
  }

  console.log('');

  // Push migrations
  const migrationsResult = pushMigrations();
  result.migrationsPushed = migrationsResult.success;

  if (!migrationsResult.success && migrationsResult.error) {
    result.errors.push(`Migration push failed: ${migrationsResult.error}`);
    log(migrationsResult.error, 'error');
  }

  // Calculate duration
  result.duration = Date.now() - startTime;
  result.success = result.typesGenerated && result.migrationsPushed;

  // Summary
  console.log('\n================================================');
  console.log('  Sync Summary');
  console.log('================================================');
  console.log(`  Types generated: ${result.typesGenerated ? 'Yes' : 'No'}`);
  console.log(`  Migrations pushed: ${result.migrationsPushed ? 'Yes' : 'No'}`);
  console.log(`  Duration: ${result.duration}ms`);

  if (result.errors.length > 0) {
    console.log('\n  Errors:');
    result.errors.forEach((e) => console.log(`    - ${e}`));
  }

  console.log('================================================\n');

  process.exit(result.success ? 0 : 1);
}

// Run
main().catch((error: unknown) => {
  const message = error instanceof Error ? error.message : String(error);
  log(`Fatal error: ${message}`, 'error');
  process.exit(1);
});
